## 汇编基础

1. #### 深入理解机器工作原理

2. #### 底层编程意识和思想

   #### 《微机原理和接口》

   #### 《组成原理》

   电子计算机的机器指令：一列二进制数字。计算机将之转换为一列高低电平，以使计算机的电子器件受到驱动，进行运算。

##### 《操作系统》《编译原理》

##### 《汇编》

##### 《计算机组成》《数字逻辑设计》



指令集--CISC



X86指令集：

向下兼容

变长指令：

1-15字节 ，多数为2-3字节长度

多种寻址方式（可访问不对齐内存地址）

通用寄存器个数有限

X86-32：8个通用寄存器

X86-64：16个



###### 1K=2^10=1024

###### 1M=1024K=2^20

###### 1G=1024M=2^30

###### 1T=1024G=2^40

###### 1P=1024T=2^50

一个二进制位：bit（比特）

8个二进制位：byte（字节）

2个字节： word

​                  1 word=2byte=16bit



机器字长：

一般指计算机进行一次整数运算所能处理的二进制数据的位数

通常也包括数据地址长度

地址按字节来定位



汇编语言指令：

1. 汇编指令：机器码的助记符，有对应的机器码
2. 伪指令：没有对应的机器码，由编译器执行，计算机并不执行
3. 其他符号 +，-，*，/等，由编译器识别，没有对应的机器码

### 存储器：

指令和数据

存储单元

CPU进行数据的读写：

1. 存储单元的地址（地址信息）

2. 器件的选择，读写命令（控制信息）

3. 读或写的数据（数据信息）

   ​

总线

![汇编](F:\Typora\汇编.JPG)



地址总线：

CPU通过地址总线指定存储器单元。

地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。

CPU最多可以寻找2^N个存储单元

数据总线：

数据总线的宽度决定了CPU和外界的数据传送速度。

一根数据总线一次传送一个二进制数据。

控制总线：

有多少根控制总线，意味着CPU提供了对外器件的多少种控制。

内存地址空间：

例：一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。

存储器芯片：

随机存储器（RAM）：

​        可读可写，但必须带电存储，关机后存储内容丢失

只读存储器（ROM）

​        只能读取，不能写入，关机后内容不丢失。![存储器](F:\Typora\存储器.JPG)

1. ​       都和CPU通过总线连接

2. ​       CPU对他们进行读写操作时通过控制线发出内存读写命令

   CPU操作时，将他们当做内存来对待。把它们总的看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。

   ![内存地址空间](F:\Typora\内存地址空间.JPG)

   内存地址空间大小收到CPU地址总线宽度的限制，

   8086CPU的地址总线宽度为20，则可以传送2^20个不同的地址信息。

   ​

##### 寄存器

内部总线实现CPU内部各个器件之间的联系

外部总线实现CPU和主板上其他器件的联系

在CPU中：

- 运算器进行信息处理
- 寄存器进行信息存储
- 控制器控制各种器件进行工作
- 内部总线连接 各种器件，在他们之间进行数据的传送

CPU中主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。可以通过改变各种寄存器中的内容实现对CPU的控制。

不同的CPU，寄存器的个数、结构不同。



### 8086CPU

14个寄存器

#### 通用寄存器

8086CPU的所有寄存器都是16位的，可以存放两个字节。

AX、BX、CX、DX：存放一般性的数据---------------------->通用寄存器

8086CPU的AX、BX、CX、DX这四个寄存器可以分为两个独立使用的八位寄存器使用。

- AX：AH  AL

- BX:   BH  BL

- CX:   CH  CL

- DX:   DH  DL

  ​

十进制

二进制

十六进制



汇编指令：

|   汇编指令    |      控制CPU完成的操作      | 用高级语言的语法描述 |
| :-------: | :------------------: | :--------: |
| mov ax,18 |      将18送进寄存器AX      |   AX=18    |
| mov ah,78 |      将78送入寄存器AH      |   AH=78    |
| add ax,8  |    将寄存器AX中的数值加上8     |  AX=AX+8   |
| mov ax,bx |    将寄存器BX中的数据送入AX    |   AX=BX    |
| add ax,bx | 将AX与BX中的数据相加，结果存在AX中 |  AX=AX+BX  |

PS:在写一条汇编指令或一个寄存器的时候，不区分大小写。



物理地址：

CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，称之为物理地址。



16位结构的CPU：

- 运算器一次最多处理十六位的数据
- 存储器的最大宽度为16位
- 寄存器和运算器之间的通路为16位

段寄存器：

8086CPU：CS、DS、SS、ES

CS和IP：

CPU当前读取指令的地址

CS：代码段寄存器

IP：指令指针寄存器

CPU从何处执行指令是有CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。

mov：传送指令

mov指令不能用于设置IP、CS的值。

能够改变CS、IP的内容的指令成为转移指令。

jum指令：

jum段地址：偏移指令

```
jum 2AE3:3 ,执行后：CS=2AE3H,IP=0003H,CPU将从2AE33H处读取指令
jum 3:0B16, 执行后：CS=0003H,IP=0B16H,CPU将从00B46H处读取指令
```

代码段：将一组内存单元定义为一个段。

```
Debug程序：
R:查看、改变CPU寄存器内容
D:查看内存中的内容
E：改写内存中的内容
U：将内存中的机器指令翻译成汇编指令
T：执行一条机器指令
A: 以汇编指令的格式在内存中写入一条机器指令
```
#### 寄存器（内存访问）

字单元：存放一个字型数据（16位）的内存单元，有两个地址连续的内存单元构成。

DS和【address】：

CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址。

8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。

```
mov 寄存器，数据     mov ax,8
mov 寄存器，寄存器    mov ax,bx
mov 寄存器，内存单元  mov ax,[0]
mov 内存单元，寄存器  mov [0],ax
mov 段寄存器，寄存器   mov ds,ax
mov 寄存器，段寄存器
```

```
[......]表示一个内存单元
[......]中的0表示内存单元的偏移地址。
8086CPU不支持将数据直接直接送入段寄存器，故需要用一个寄存器进行中转。
```

```
段地址*16+偏移地址=物理地址

CPU在访问内存时，用一个基础的地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。
```

```
内存并没有分段，段的划分来自于CPU，由于8086CPU用“基础地址+偏移地址=物理地址”的方式给出内存单元的物理地址。使得我们可以用分段的方式来管理内存。
```

#### 段寄存器：

1. 代码段寄存器CS：存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储段获得，相应的偏移量由IP提供。
2. 数据段寄存器DS：指出当前程序使用的数据所存放段的最低地址。
3. 堆栈段寄存器SS：指出当前堆栈的底部地址，即存放堆栈段的段基址。
4. 附加段寄存器ES：指出当前程序使用附加数据段的段基址。

字节      字

```
危机原理寻址中，物理地址=段寄存器*16+偏移地址
ps：16是10进制的16，相当于16进制的10

```

栈：

入栈和出栈

入栈：讲一个新的元素放到栈顶

出栈：从栈顶取出一个元素

LIFO（Last IN First Out，后进先出）

8086CPU用SS和SP指示栈顶的地址。

8086CPU不保证我们对栈的操作不会超界。

在编程时，注意栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致超界；执行出栈操作的时候也要注意，防止栈空的时候继续出栈而导致的超界。

```
push 寄存器      将一个寄存器中的数据入栈
pop  寄存器      出栈，用一个寄存器接受出栈的数据

push  段寄存器
pop   段寄存器

push 内存单元  （栈的操作都是以字为单位）
pop  内存单元
```

```
//ax清零
mov ax,0 机器码为三个字节
sub ax,ax 机器码为两个字节
```

-----------------------------------------------------------------------------------------------

将10000H-1000FH这段空间看做栈。

![栈](F:\Typora\栈.JPG)

#### 伪指令

```
XXX segment
......
......
XXX ends
//定义一个段
//XXX为段名
```

```
end：汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。
```

```
assume
//假设
假设某一段寄存器和程序中的某一个用segment......ends定义的段向关联。
将有特定用途的段和相关的段寄存器关联起来即可。
```

汇编源程序：汇编指令   伪指令   标号（代表地址）



程序返回：

DOS(一个单任务操作系统)上，一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载如内存后，将CPU的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行。当P2运行完毕后，应该讲CPU的控制权交还给使得他可以运行的程序P1，此后，P1继续运行。

程序返回：

mov ax,4c00H

int 21H

```
编译源程序：
edit
//编辑--保存（C:\1.asm）
//编译  
//使用masm汇编编译器
//进入masm
/*编译文件路径
如果在当前路径下，只要输入文件名就可以
如果在其他目录下，就要输入路径
ps:c:\windows\desktop\pl.txt
*/
如果被编译的源程序文件的扩展名为“.asm”，直接输入文件名即可，如果不是，则需要输入文件名加格式的方式编译。

编译输出：
1、目标文件（.obj）
2、列表文件（.lst）
3、交叉引用文件（.crf）
```



连接：

在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。

```
//Overlay Linker连接器
/* c:\masm>link
*/
```

连接的作用：

1. 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们链接到一起，生成一个可执行文件。
2. 程序中调用了某个库文件中的子程序，需要将这个库文件和改程序生成目标文件连接到一起，生成一个可执行文件。
3. 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行文件。

以简化的方式进行编译和连接：

```
masm c:\1;
//在masm后面加上被编译的源程序文件的路径、文件名，在命令行的结尾加上分号，按enter键后，编译器对文件进行编译，在当前路径下生成目标文件1.obj，并在编译的过程中自动忽略中间文件的生成。
link 1;
//执行1.exe
1

```

操作系统的外壳：

操作系统是有多个功能模块组成的庞大、复杂的操作系统。任何通用的操作系统，都要提供一个成为shell（外壳）的程序，用户使用这个程序来操作计算机系统完成工作。

DOS中有一个程序command.com，这个程序在DOS中称为命令解释器，就试试DOS系统的shell。

在DOS中，command处理各种输入：命令或者要执行程序的文件名。我们就是通过command来进行工作的。



程序执行过程跟踪：

```
debug 1.exe
-r:查看各个寄存器的设置情况
-u
-t:单步执行每一条指令
-p:执行int21
```



[BX]和loop指令：

```
[0]表示内存单元，偏移地址为0.
ps:mov ax,[0]
   将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个子，偏移地址为0，段地址在ds中。
```

完整的描述一个内存单元：内存单元的地址  内存单元的长度（类型）

[bx]：一个内存单元，偏移地址在bx中，段地址在ds中

loop：CPU执行loop指令的时候，要进行两步操作：

​          1、（cx）=(cx)-1

​          2、判断cx中的值，不为零则转至表好处执行指令，为0则向下执行

```
例：计算2^11

assume cs:code

code segment
   mov ax,2
   mov cx,11
   s:add ax,ax
   loop s
   
   mov ax,4c00h
   int 21h
 code ends
 end

```

```
mov cx,循环次数

s:
   循环执行的代码段
   loop s
```